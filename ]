use std::iter::{Enumerate, Peekable};
use std::str::{Chars, Lines};


use crate::token::{Token, TokenKind, RegSize};
use crate::location::Span;
use crate::logger::{Log, Logs, Level};

use crate::debug;

pub struct Lexer<'a> {
    logger:   &'a mut Vec<Log>,
    filename: &'static str,

    lines:    Lines<'a>, // first element is always the next line
    li:       usize, // current line index

    chars:    Peekable<Chars<'a>>, // chars of the current line
    ci:       usize,

    tokens:   Vec<Token>,
}

impl Lexer<'_> {
    pub fn new<'a>(input: &'a str, logger: &'a mut Vec<Log>, filename: &'static str) -> Lexer<'a> {
        let mut lines = input.lines();

        let Some(line) = lines.next() else {
            panic!("file cannot be empty... the reader should filter this");
        };

        let chars = line.chars().peekable();

        Lexer{ logger, filename, lines, li: 1, chars, ci: 0, tokens: Vec::new()}
    }

    pub fn lex(mut self) -> Vec<Token> {
        while let Some(c) = self.next() {
            use TokenKind::*;
            let token = match c {
                '&' => Ampersand,
                '@' => At,
                '\\'=> Backslash,
                '!' => Bang,
                '^' => Caret,
                ':' => Colon,
                ',' => Comma,
                '$' => Dollar,
                '.' => Dot,
                '"' => DoubleQuote,
                '=' => {
                    if self.test_next('>') { FatArrow }
                    else { Equals }
                },
                '>' => {
                    if self.test_next('=') { GreaterThanEquals }
                    else { GreaterThan }
                },
                '{' => LeftBrace,
                '[' => LeftBracket,
                '(' => LeftParen,
                '<' => {
                    if self.test_next('=') { LessThanEquals }
                    else { LessThan }
                },
                '-' => {
                    if self.test_next('-') { MinusMinus }
                    else if self.test_next('>') { TinyArrowRight }
                    else { Minus }
                },
                '~' => {
                    if self.test_next('=') { NotEquals }
                    else { Tilde }
                },
                '%' => Percent,
                '|' => Pipe,
                '+' => {
                    if self.test_next('+') { PlusPlus }
                    else { Plus }
                },
                '#' => Pound,
                '?' => Question,
                '}' => RightBrace,
                ']' => RightBracket,
                ')' => RightParen,
                ';' => Semicolon,
                '\''=> SingleQuote,
                '/' => Slash,
                '*' => Star,
                ' ' | '\t' => {
                    // prevent doubled whitespace
                    if self.tokens.last().is_some_and(|t| t.kind == WS) { continue; }
                    WS
                },

                c if c.is_ascii_alphabetic() || c == '_' => {
                    let word = self.word();
                    
                    if word.is_empty() {
                        if c == '_' { Underscore }
                        else { Ident(String::from(c)) }
                    }

                    else {
                        let mut word = format!("{}{}", c, word);

                        // registers
                        if let Some(word) = word.strip_prefix('r') {
                            if word.chars().next().unwrap().is_numeric() { 
                                self.parse_register(word.to_string());
                            }
                        }

                        match word.as_str() {
                            // keywords
                            "jmp" => Jmp,
                            "ret" => Ret,
                            "end" => End,
                            "init" => Init,
                            "static" => Static,
                            "const" => Const, 
                            "entry" => Entry,

                            _ => Ident(word),
                        }
                    }
                },

                '0' => {
                    let Some(c) = self.chars.next() 
                        else { return self.tokens; };

                    let word = self.word();

                    match c {
                        'b' => BinLit(self.num(word, 2).unwrap()),
                        'o' => OctLit(self.num(word, 8).unwrap()),
                        'x' => HexLit(self.num(word, 16).unwrap()),
                         _  => DecLit(self.num(word, 10).unwrap()),
                    }
                },

                c if c.is_numeric() => {
                    let word = format!("{}{}", c, self.word());

                    if word.contains('.') {
                        FloatLit(word.parse::<f64>().unwrap())
                    }
                    else {
                        DecLit(self.num(word, 10).unwrap()) 
                    }
                },


                // // literals
                // CharLit(char),
                // FloatLit(f64),
                // StrLit(usize),
                
                t => {
                    // temporary
                    debug!("Unknown token: {:?}", t);
                    EOF
                },
            };

            self.tokens.push(self.to_span().to_token(token));
        }

        self.tokens
    }

    // always TokenKind::Register
    fn parse_register(&mut self, mut reg: String) -> Option<TokenKind> {
        use RegSize::*;
        let size = match reg.pop().unwrap() {
            'q' => QWord,
            'd' => DWord,
            'w' => Word,
            'h' => HighByte, // high byte represented as 0... prob better idea to have some kind of enum
                      // for register size but it is what it is. This is a legacy feature of x86
                      // anyway so we might end up removing it as no compiler actually takes it
                      // into account.. maybe?
            'b' => Byte,
            _ => {
                self.to_span()
                    .length(reg.len())
                    .to_log()
                    .level(Level::Err)
                    .msg("Invalid token in register identifier")
                    .push(self.logger);
                return None;
            },
        };

        let Ok(num) = reg.parse::<usize>() else {
            self.to_span()
                .length(reg.len())
                .to_log()
                .level(Level::Err)
                .msg("Invalid token in register identifier")
                .push(self.logger);
            return None;
        };

        Some(TokenKind::Register(size, num))
    }

    fn test_next(&mut self, test: char) -> bool {
         self.chars.peek()
             .is_some_and(|&c| c == test)
    }

    fn next(&mut self) -> Option<char> {
        match self.chars.next() {
            Some(c) => {
                self.ci += 1;
                Some(c)
            },
            None => match self.next_line() {
                Some(l) => self.next(),
                None => {
                    self.tokens.push(self.to_span().to_token(TokenKind::EOF));
                    None
                },
            },
        }
    }

    fn num(&mut self, word: String, base: u32) -> Option<usize> {
        match usize::from_str_radix(&word, base) {
            Ok(n) => Some(n),
            Err(e) => {
                self.to_span()
                    .length(word.len())
                    .to_log()
                    .level(Level::Err)
                    .msg("Invalid integer literal")
                    .notes(e)
                    .push(self.logger);
                None
            },
        }
    }

    fn word(&mut self) -> String {
        let mut word = String::new();
        while let Some(&c) = self.chars.peek() {
            if !c.is_ascii_alphanumeric() { break; }

            let _ = self.chars.next();
            word.push(c);
        } word
    }

    fn next_line(&mut self) -> Option<&str> {
        match self.lines.next() { 
            Some(l) if l.trim().is_empty() => self.next_line(),
            Some(l) => {
                self.li += 1;
                self.ci = 0;
                self.chars = l.chars().peekable();


                self.tokens.push(self.to_span().to_token(TokenKind::NL));

                Some(l)
            }
            None => None,
        }
    }

    fn to_span(&self) -> Span {
        Span::new(self.filename, self.li, self.ci)
    }

}
